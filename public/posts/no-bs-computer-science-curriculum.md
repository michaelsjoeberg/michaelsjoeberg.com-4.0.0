<!--
    No-BS Computer Science Curriculum
    Michael Sjöberg
    November 10, 2020
-->

## <a name="1" class="anchor"></a> [1. Introduction](#1)

This is an evolving list with learning material and recommended programming languages for computer science students. It works well on its own (for self-learners) or in addition to an undergraduate degree in computer science (or related field). The goal is to provide a solid foundation to build upon, degree or no degree. It will be updated to fix broken links and to keep learning material up-to-date.

If you are interested in computer science and engineering (and have plenty of time to spare), see [github.com/michaelsjoeberg/the-ultimate-computer-science-and-engineering-curriculum](https://github.com/michaelsjoeberg/the-ultimate-computer-science-and-engineering-curriculum).

## <a name="2" class="anchor"></a> [2. Programming](#2)

In this section: [Foundation](#2.1), [Paradigm exposure](#2.2), [Machine learning](#2.3), ["Modern" languages](#2.4)

Programming is the most important skill in computer science and computational problem solving, and should be the primary focus of any computer science curriculum (with use cases in computer systems, application software development, theorem proving, and so on). If you prefer to work on projects while learning, see [github.com/tuvtran/project-based-learning](https://github.com/tuvtran/project-based-learning).

### <a name="2.1" class="anchor"></a> [Foundation](#2.1)

The goal is to get comfortable with programming and to understand the software abstraction model (via Python, C, and Assembly; high-level to low-level, with Python representing the highest-level of abstraction). You most likely don't need to be fluent in any Assembly language (they are mostly compilation targets), but to be able to read and find errors in assembly generated by smaller programs is probably a good idea.

- **Python**
	- Get proficient or fluent (very powerful programming language with a lot of support, look at some numerical libraries as well, especially NumPy)
	- Try to implement an interpreter; see [Let’s Build A Simple Interpreter](https://ruslanspivak.com/lsbasi-part1/)
	- **Bonus:** Try to implement game of life; see [Programming Projects for Advanced Beginners #2: Game of Life](https://robertheaton.com/2018/07/20/project-2-game-of-life/).

- **C**
	- Learn basics of memory allocation and pointers; try to understand the assembly code generated for smaller programs (gcc -S option)
	- Get familiar with C++ (could also get proficient or fluent if appropriate)

- **Assembly**
	- x86, ARM (could also explore other architectures if more appropriate); see [x86 Assembly Guide](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html) and [ARM Hardware and Assembly Language](https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/arm-asm/)
	- Get familiar with registers; see [x86 Assembly/X86 Architecture](https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture)

Recommended learning material: [Computer Systems: A Programmer's Perspective](https://www.amazon.com/Computer-Systems-OHallaron-Randal-Bryant/dp/1292101768), [The Art of Assembly Language](https://www.amazon.com/Art-Assembly-Language-2nd/dp/1593272073), [C Programming Language](https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628), [A Tour of C++](https://www.amazon.com/Tour-2nd-Depth-Bjarne-Stroustrup/dp/0134997832), [Python Crash Course](https://www.amazon.com/Python-Crash-Course-2nd-Edition/dp/1593279280).

### <a name="2.2" class="anchor"></a> [Paradigm exposure](#2.2)

The goal is to get familiar with a range of programming paradigms, understand parts of the hardware abstraction model (via Verilog), and become a more confident computer programmer in general. A few notes on programming languages: Python and C (and C++) are considered multi-paradigm (as in supporting more than one style), and more specifically: imperative and structured.

- **Haskell**
	- Functional

- **Prolog**
	- Declarative and probably most popular logic-based programming language
	- **Bonus:** Get familiar with Coq (one of the most popular theorem provers); see [Coq in a Hurry](https://arxiv.org/pdf/cs/0603118.pdf)

- **Verilog**
	- Hardware description language; probably most popular language to design and verify digital systems
	- **Bonus:** Try to implement designs at different abstraction levels (gate-level, register-transfer-level, behavioural-level); see [Verilog Tutorial](https://www.javatpoint.com/verilog)

Recommended learning material: [Thinking Functionally with Haskell](https://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643), [The Elements of Computing Systems](https://www.amazon.com/Elements-Computing-Systems-Building-Principles/dp/0262640686), [Structure and Interpretation of Computer Programs](https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871).

What about object-oriented programming? *"[at] big companies, software tends to be written by large (and frequently changing) teams of mediocre programmers. Object-oriented programming imposes a discipline on these programmers that prevents any one of them from doing too much damage"*, read this post by Paul Graham (Viaweb, Y Combinator): [Why Arc Isn't Especially Object-Oriented](http://www.paulgraham.com/noop.html).

### <a name="2.3" class="anchor"></a> [Machine learning](#2.3)

The goal is to get exposed to machine learning and the idea that output is based on data instead of design, watch this talk by Andrej Karpathy (former director of AI at Tesla): [Building the Software 2.0 Stack](https://databricks.com/session/keynote-from-tesla).

- **Neural Networks** (Python)
	- Get familiar with Scikit-learn, PyTorch, and TensorFlow (or any other similar framework if more appropriate)
	- **Bonus:** Try to build a neural network from scratch; see [How to build your own Neural Network from scratch in Python](https://towardsdatascience.com/how-to-build-your-own-neural-network-from-scratch-in-python-68998a08e4f6)

Recommended learning material: [The Hundred-Page Machine Learning Book](https://www.amazon.com/Hundred-Page-Machine-Learning-Book/dp/199957950X).

### <a name="2.4" class="anchor"></a> ["Modern" languages](#2.4)

The above topics provides familiarity with different paradigms and modern developments (such as ML). Below are few more programming languages to consider, somewhat based on the "most loved" programming languages: [Stack Overflow Developer Survey 2020](https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted).
	
- **Rust** (backed by Mozilla)
	- Natural transition from C++, could also explore Scala if more familiar with Java
	- **Bonus:** Try to build an operating system; see [Writing an OS in Rust](https://os.phil-opp.com/)

- **Clojure**
	- Lisp-like, could also explore Lisp if more appropriate

- **Nim**
	- Python-like but compiled

- **Kotlin**
	- Probably most popular language for Android development (see [Kotlin is now Google's preferred language for Android app development](https://techcrunch.com/2019/05/07/kotlin-is-now-googles-preferred-language-for-android-app-development)), compiles to JVM and JavaScript (could also explore Lua if interested in embedded applications or game development)

- **Go** (backed by Google)
	- Memory safe C (if you don't like Rust, could also explore Dart)

## <a name="3" class="anchor"></a> [3. Mathematics](#3)

In this section: [Basics](#3.1), [General topics](#3.2)

Mathematics has a central role in any computer science curriculum and a solid foundation in selected mathematical topics can be highly valuable, especially in more advanced computing tasks (not to mention ML).

### <a name="3.1" class="anchor"></a> [Basics](#3.1)

The Goal is to get familiar with data structures and theory of computation, these topics could also be covered in recommended learning material for some programming languages.

- **Discrete Mathematics**
	- Get familar with sets, permutations, trees, graphs, and related concepts
	- **Bonus:** Try to implement common algorithms in different programming languages (optimize based on different conditions); see [The Algorithms](https://github.com/TheAlgorithms)

- **Probability**
	- Learn basics of probability distributions and conditionality; see [Khan Academy: Statistics and probability](https://www.khanacademy.org/math/statistics-probability)
	- **Bonus:** Try to implement concepts based on random processes (such as MDP solver, see [aimacode](https://github.com/aimacode)), could also explore game theory if more appropriate

Recommended learning material: [Discrete Mathematics](https://www.amazon.com/Discrete-Mathematics-Gary-Chartrand/dp/1577667301), [Introduction to Algorithms](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844).

### <a name="3.2" class="anchor"></a> [General topics](#3.2)

The goal is to build a strong general background in mathematics, such as typically taught in undergraduate science-related degrees. Many topics are useful in several tasks related to computer science, but in particular ML, computer vision, and scientifc computing.

- **Calculus**
	- Get familiar with derivatives and anti-derivatives, multivariable derivatives, and vector calculus 
	- **Bonus:** Learn basics of partial derivatives, Jacobian computations, and relevant optimization techniques

- **Linear Algebra**
	- Get familiar with vectors, spaces, matrix transformations, and related concepts (get fluent if interested in computer vision)
	- **Bonus:** Implement inverse, determinant, and transpose in some programming language

- **Differential Equations**
	- Learn basics of first-order, second-order, and partial differential equations

- **Number Theory**
	- Get familiar with topics in number theory (any interesting); see [List of number theory topics](https://en.wikipedia.org/wiki/List_of_number_theory_topics)
	- **Bonus:** Try to solve computational problems; see [Project Euler](https://projecteuler.net/)

Recommended learning material: [Calculus: Early Transcendentals](https://www.amazon.com/Calculus-Early-Transcendentals-James-Stewart/dp/1285741552), [No bullshit guide to linear algebra](https://www.amazon.com/No-bullshit-guide-linear-algebra/dp/0992001021), [Ordinary Differential Equations](https://www.amazon.com/Ordinary-Differential-Equations-Dover-Mathematics/dp/0486649407), [Elementary Analysis: The Theory of Calculus](https://www.amazon.com/Elementary-Analysis-Calculus-Undergraduate-Mathematics/dp/1461462703), [Number Theory](https://www.amazon.com/Number-Theory-Dover-Books-Mathematics/dp/0486682528).

## <a name="4" class="anchor"></a> [4. Other skills](#4)

This section contains additional topics and commonly used tools, somewhat based on the *"missing semester"* at MIT, see [The Missing Semester of Your CS Education](https://missing.csail.mit.edu/).

- **Git**
	- Probably most common version control system

- **Bash**
	- Domain-specific command language (Unix shell); get familiar with frequently used commands at [Bash scripting cheatsheet](https://devhints.io/bash)

- **JavaScript**
	- Event-driven programming language (control flow based on events)
	- Get proficient if you want to work with web technologies

It is also a good idea to get familiar with virtual machines, such as Vagrant or Docker, build systems, such as Make, cloud platforms, such as AWS or Google Cloud, and parallel computing, such as CUDA or OpenCL. Finally, getting used to notebooks is probably a good idea, such as Jupyter (Python), which is a very popular development environment for ML and deep learning.
