Lecture notes on security engineering, part 3: Assembly
Michael Sjöberg
Aug 29, 2022
May 27, 2023

## <a name="1" class="anchor"></a> [Assembly basics](#1)

An assembly language is a low-level symbolic language with processor specific instructions and syntax, such as those developed by AT&T and Intel. Instructions and syntax, as well as data types, registers, and hardware support, is typically specified by some instruction set architecture (ISA), which is an abstract model of some computer implementation. An assembly program is a sequence of instructions, where each instruction represents an actual operation to be performed by the processor.

In most assembly-like languages, an instruction has the form `mnemonic <source>, <destination>` (AT&T syntax), such as `mov %eax, %ebx` to copy value from `%eax` to `%ebx`, or `mnemonic <destination>, <source>` (Intel syntax):

- mnemonics tell the CPU what to do
    - `mov` `add` `sub` `push` `pop` `call` `jmp`

- source and destination
    - registers, `%eax` `%esp` `%al`
    - memory location, such as `0x401000, 8(%ebp)` or `%edx, %ecx, 4`
    - constants (source only), such as `$42` or `$0x401000`

- directives are commands for assembler
    - `.data` to identify section with variables
    - `.text` to identify section with code
    -  `.byte` `.word` `.long` to define integer as 8, 16, or 32-bit (respectively)
    - `.ascii` or `.asciz` to define string with and without terminator

- labels are symbol at current address, so `number: .byte 42` is same as `char number = 42;` in C (global variable)

#### Registers

A register is a memory location on the CPU and prefixed with `%`, such as general-purpose registers, including stack pointer `%esp`, frame pointer `%ebp`, instruction pointer `%eip`, and flags register (note that `%esp`, `%ebp`, and `%eip` is 32 bit, and `%rsp`, `%rbp`, and `%rip` is equivalent 64 bit):

- extended (32-bit)
    - `%eax` `%ebx` `%ecx` `%edx` `%esi` `%edi`
- smaller parts (16-bit)
    - `%ax` `%bx` `%cx` `%dx` `%sp` (stack pointer) `%bp` (frame pointer) `%si` `%di`
- lower byte
    - `%a1` `%b1` `%c1` `%d1`
- second byte
    - `%ah` `%bh` `%ch` `%dh`

A constant is prefixed with `$` and the operand size is specified as suffix to mnemonic, so byte is `b` (8 bit), word is `w` (16 bit), and long is `l` (32-bit or 64-bit floating point). An initial layout (bits 0-15 is `%ax` and 0-31 is extended, `%eax`) and final layout after `mov $1, %eax`, copy 1 and set rest to zero:

|     |      |      |      |
| --- | ---  | ---  | ---  |
| `%a1` | `%ah` |
| 0 | 8 | 16 | 31 |

|     |     |     |     |
| --- | ---  | ---  | ---  |
| `%a1` | `%ah` |
| 10000000 | 00000000 | 0 – 0 | 0 – 0 |
| 0 | 8 | 16 | 31 |

Memory is accessed using pointers, which are variables that store memory addresses. Dereferencing a pointer means accessing the value stored at the memory address pointed to by the pointer. In order to dereference a pointer, the memory address must be computed based on the contents of the base and index registers, and an optional constant displacement and scaling factor scale.

The exact syntax for dereferencing a pointer depends on the architecture and instruction set used by the processor.

## <a name="2" class="anchor"></a> [Assembly programming](#2)

Assembly programs are typically generated by compilers, but it can sometimes be necessary to inspect or change manually. Writing programs using only assembly instructions is not very efficient and can be very error prone.

Below is an assembly program to output `hello assembly`.

```x86asm
; assembly program (64-bit, intel syntax)
section .text
    global _main        ; start point for execution

_main:
    mov rax, 1          ; write (system call)
    mov rdi, 1          ; stdout
    mov rsi, msg        ; address to output
    mov rdx, 14         ; bytes to output
    syscall             ; invoke write
    mov rax, 60         ; exit (system call)
    xor rdi, rdi        ; 0
    syscall             ; invoke exit

section .data
    ; db is raw bytes and line feed \n is 0xah, or 10
    msg db "hello assembly", 10
```

It is often easier to explore assembly programs in emulators, such as [nasm Online Compiler](https://rextester.com/l/nasm_online_compiler) or [Compiler Explorer](https://godbolt.org/).

#### Data transfer

```x86asm
; set destination as source
mov <source>, <destination>

; swap destinations
xchg <destination>, <destination>

; store source on top of stack
push <source>

; get destination from top of stack
pop <destination>
```

#### Binary arithmetic

```x86asm
; addition, destination += source
add <source>, <destination>

; subtraction, destination -= source
sub <source>, <destination>

; increment, destination += 1
inc <destination>

; decrement, destination -= 1
dec <destination>

; negation, destination = -destination
neg <destination>
```

#### Logical operators

```x86asm
; and, destination &= source
and <source>, <destination>

; or, destination |= source
or <source>, <destination>

; exclusive or, destination ^= source
xor <source>, <destination>

; not, destination = ~destination
not <destination>
```

#### Unconditional branches

```x86asm
; jump to address
jmp <address>

; push return address and call function at address
call <address>

; pop return address and return
ret

; call OS-defined handler represented by const
int <const>
```

#### Conditional branches

```x86asm
; jump below (unsigned), %eax < %ebx (label is location)
cmp %ebx, %eax
jb <label>

; jump not less (signed), %eax >= %ebx
cmp %ebx, %eax
jnl <label>

; jump zero, %eax = 0
test %eax, %eax
jz <label>

; jump not signed, or not below (signed), %eax >= 0
cmp $0, %eax
jns <label>
```

#### Other instructions

```x86asm
; load effective address (source must be in memory), destination = &source
lea <source>, <destination>

; do nothing
nop
```

#### [Next part](lecture-notes-on-security-engineering-part-4)
